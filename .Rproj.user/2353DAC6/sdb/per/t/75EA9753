{
    "collab_server" : "",
    "contents" : "funkcja2 <- function (x, y, z){\n  \n  # Tworzymy macierz, gdzie ka?da cz. listy to 1 plik\n  inFile <- x\n  a = list()\n  for (i in 1:length(x[, 1])){ \n    a[[i]] <- read.table(textConnection(rev(rev(readLines(inFile$datapath[i]))[-(1:10)])),\n                         skip = 10, header = T, sep = \"\\t\", nrows = 68)\n  }\n  \n  # Wydajno??\n  inFile2 <- y\n  plates <- read.xlsx(inFile2$datapath, header = T, 4)\n  \n  efficiency <- read.xlsx(inFile2$datapath, header = T, 1)\n  eff <- efficiency[efficiency[, 1] %in% as.matrix(data.frame(strsplit(inFile$name, '_'))[1, ]), 2]\n  \n  # Creating a  matrix with all sample names for all sets based on the config file\n  \n  set <- data.frame(read.xlsx(inFile2$datapath, header = T, 3))\n  sets <- unique(set[efficiency[, 1] %in% as.matrix(data.frame(strsplit(inFile$name, '_'))[1, ]), 2])\n  uniques <- unique(unlist(subset(plates, select=as.character(sets))))\n  uniques <- sort(uniques[is.finite(uniques)])\n  \n  # Slecting reference genes\n\n  k = 1\n  ref <- list()\n  j <- 1\n  liczba_usuniec <- 0\n  ref_index <- c()\n\n\n  for (i in 1:length(z)){\n    for (j in 1:length(a)){\n      if (strsplit(inFile$name[j], '_')[[1]][1] == z[i]){\n        #Przypisywanie plik?w z genami ref do nowej zmiennej\n        ref[[k]] = a[[j]]\n\n\n\n        k=k+1\n        #Usuwanie z listy normalnych gen?w\n\n\n        ref_index[k - 1] <- j\n      }}}\n\n  k <- 1\n  for (i in ref_index){\n    j <- i + 1 - k\n    a[[j]] <- NULL\n    k <- k + 1\n  }\n\n\n  ### Sprawdzanie, czy s? geny referencyjne i zwyk?e\n  if (length(ref) > 0 & length(a) > 0){\n\n    ### Obliczenia dla gen?w referencyjnych\n    #Obliczanie dCt dla ref\n\n    sample_no <- length(ref[[1]][, 1])\n    \n    # Ct values for reference genes are matched to corresponding names\n    \n    refCt <- data.frame(matrix(nrow = length(ref), ncol = sample_no))\n    refdCt <- refCt\n    preQ <- refCt\n    refnames <- refCt\n\n    for (i in 1:length(ref)){\n      refCt[i, ] <- as.numeric(as.character(ref[[i]][, 6]))\n      refCal <- mean(as.numeric(as.character(ref[[i]][(sample_no-5):sample_no, 6])), na.rm = T)\n      refdCt[i, ] <- refCal - refCt[i, ]\n      refnames[i, ] <- ref[[i]][, 2]\n    }\n\n    \n    # Obliczamy Q, czyli potrzebne s? wydajno?ci\n    for (i in 1:length(ref)){\n      preQ[i, ] <- eff[ref_index[i]]^refdCt[i, ]\n    }\n\n    \n    refQ <- data.frame(matrix(nrow = 1, ncol = length(uniques)))\n    colnames(refQ) <- uniques\n    \n    # Geometric average. We create a list because we expect different number of data per sample.\n    for (i in 1:length(uniques)){\n\n      x <- which(colnames(refQ)[i] ==  refnames, arr.ind = T)\n      \n      if(length(x) > 0)\n      {\n\n      refQ[i] <- (prod(preQ[x[,1],x[,2]], na.rm = T))^(1/sum(!is.na(preQ[x[,1],x[,2]])))\n\n      }else{\n        refQ[i] <- NA}\n\n      }\n\n\n    ##### Przygotowanie danych\n    # Obliczanie dCt\n    Ct <- data.frame(matrix(nrow = length(a), ncol = sample_no))\n    Q <- Ct\n    samnames <- Ct\n    Cal <- c()\n\n    for (i in 1:length(a)){\n      Ct[i, ] <- as.numeric(as.character(a[[i]][, 6]))\n      Cal[i] <- mean(as.numeric(as.character(a[[i]][(sample_no-5):sample_no, 6])), na.rm = T)\n      samnames[i, ] <- a[[i]][, 2]\n      }\n    dCt <- Cal - Ct\n\n    # Obliczamy Q, czyli potrzebne s? wydajno?ci\n\n    gene_index <- c(1:(length(a)+length(ref_index)))[-ref_index]\n\n    for (i in 1:length(a)){\n      Q[i, ] <- eff[gene_index[i]]^dCt[i, ]\n    }\n\n\n\n    ### Fold difference\n\n    Fd <- data.frame(matrix(ncol = length(gene_index), nrow = length(uniques))) #Tu by?o sample_no\n    rownames(Fd) <- uniques\n    x <- matrix()\n\n    for (i in 1:length(gene_index)){\n      for (j in 1:length(uniques)){\n\n        # We match data to corresponding names\n        # Each data matrix has corresponding matrix with their corresponding sample names\n        x <- which(rownames(Fd)[j] == samnames[i, ], arr.ind = T)\n        if (length(x) > 0){\n        Fd[j, i] <- Q[i, x[, 2]]\n        }else{\n        Fd[j, i] <- NA\n        }\n        Fd[j, i] <- Fd[j, i]/refQ[which(rownames(Fd)[j] == colnames(refQ))] #?le, trzeba dopasowa? pr?bki z gen?w do ref.\n      }\n    }\n\n    Fd <- cbind(uniques, Fd)\n\n\n      #Nazwy wierszy i kolumn\n\n\n      k <- 1\n      columns <- c()\n\n      for (i in gene_index){\n        columns[k] <- strsplit(inFile$name[i], '_')[[1]][1]\n        k <- k + 1\n\n        Fd[is.na(Fd)] <- c('No data')\n      }\n      colnames(Fd) <- c('Sample Name', columns)\n    \n\n  } else if ( length(ref) == 0) {\n    Fd <- c('No reference genes')\n  } else{\n    Fd <- c('No genes for the analysys (all genes are reference genes)')\n\n\n  }\n  return(Fd)\n         \n}\n\n# Wczytanie danych\n# Zapyta?, czy o to chodzi i o dane z r??nymi nazwami pr?bek (raczej nie b?dzie)\n# Zbada? to NA w match()\n\n# Genenames[i, ] - sprawdzi? ilo?? pr?bek dla ka?dego !!! +\n# Trzeba dopasowa? pr?bki z gen?w do ref. Trzeba to zrobi? w p?tli, gdzie si? liczy ?redni? geometryczn?\n\n#Nie dzi?a dla kilku gen?w ref!!!\n#Wyniki s? w r??nej kolejno?ci\n\n#samnames is the same size as Q, and hac names in the cells corresponding to each Q value\n#Czy zmienił się wybór wydajności na zły?\n",
    "created" : 1494497166749.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1895654407",
    "id" : "75EA9753",
    "lastKnownWriteTime" : 1494581775,
    "last_content_update" : 1494581775544,
    "path" : "C:/Users/jakpo_000/Desktop/Nauka/Inzynierka/Program/thesis/R/funkcja2.R",
    "project_path" : "R/funkcja2.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}